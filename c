<1>
单引号和双引号在C中的意义完全不同，包围在单引号中的一个字符只是编写整数的另一种方法。这个整数是给定的字符在实现的对照序列中的一个对应的值，即ASCII码值。
因此在一个ASCII实现中，‘a’和0141或97表示完全相同的东西，而一个包围在双引号中的字符串，只是编写一个有双引号之间的字符和一个附加的二进制为零的字符所初始
化的一个无名数组的指针的一种简短方法。使用一个指针来代替一个整数通常会得到一个警告消息（反之亦然），使用双引号来代替单引号也会得到一个警告消息（反之亦然）。
但通常对不检查参数类型的编译器却除外。因此用printf('\n');来代替printf("\n");通常在运行时得到奇怪的结果。因为'\n'代表一个整数，它被转换为了一个指针，
这个指针所指向的内容是没有意义的。由于一个整数通常足够大，以至于可以放下多个字符，一些C编译器允许在一个字符常量中存放多个字符，这意味着用'yes'来代替
'"yes"将不会被发现，后者意味着“包含yes和一个空字符的四个连续存储区域中的第一个的地址”，而前者意味着“在一些实现定义的样式中表示由yes联合构成的一个整数”。这两者之间的任何一致性都是巧合。


<2>
__declspec(dllexport):
 将一个函数声名为导出函数，就是说这个函数要被其他程序调用，即作为DLL的一个对外函数接口。
   通常它和extern    "C"   合用，形式如下：
extern "C"
{
__declspec(dllexport) RETURN_TYPE FUNCTION()

<3>
是c语言中的位运算符：取反.
0在内存中的存储方式是所有位为0,
0000000000000000
那么按位取反后位16个1（如果整形在你的机器上站16位）,那么表示的数为-1.


<4>
int *p;则p是一个指向int型的变量的地址， p是地址；  
*p指的是内容
而int **p；p指的是一个地址，p放的是*p的地址， *p指的是存放int 的地址.

<5>
 void关键字的使用规则：
1. 如果函数没有返回值，那么应声明为void类型；
2. 如果函数无参数，那么应声明其参数为void；
3. 如果函数的参数可以是任意类型指针，那么应声明其参数为void * ；
4. void不能代表一个真实的变量；

<6>
(int *)是强行转换
*(int *) 是强行转换后去指针指向变量的值


<7>
static全局变量与普通的全局变量有什么区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
static局部变量和普通局部变量有什么区别：static局部变量只被初始化一次，下一次依据上一次结果值；
static函数与普通函数有什么区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝；
static成员函数与普通成员函数的区别是:普通成员函数在参数传递时编译器会隐藏地传递一个this指针.通过this指针来确定调用类产生的哪个对象;但是静态成员函数没有this指针,不知道应该访问哪个对象中的数据,所以在程序中不可以用静态成员函数访问类中的普通变量.

<8>
memcpy-memmove-strcpy
memcpy() 用来复制内存，其原型为：
    void * memcpy ( void * dest, const void * src, size_t num );
memcpy() 会复制 src 所指的内存内容的前 num 个字节到 dest 所指的内存地址上。
memcpy() 并不关心被复制的数据类型，只是逐字节地进行复制，这给函数的使用带来了很大的灵活性，可以面向任何数据类型进行复制。
需要注意的是：
dest 指针要分配足够的空间，也即大于等于 num 字节的空间。如果没有分配空间，会出现断错误。
dest 和 src 所指的内存空间不能重叠（如果发生了重叠，使用 memmove() 会更加安全）。
与 strcpy() 不同的是，memcpy() 会完整的复制 num 个字节，不会因为遇到“\0”而结束。


    
    
    






