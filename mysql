<1>
      原子性，一致性，隔离性，持久性。
<2>
      除非有其他非常特殊的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。
<3>
      尽量避免NULL，通常情况下最好指定列为NOT NULL，因为可为NULL的列使得索引，索引统计和值比较都更复杂。可为NULL的列会使用更多地存储空间，在mysql
里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。
<4>
      尽量避免使用BLOB和TEXT类型，因为MEMORY引擎不支持BLOB和TEXT类型，所以如果查询使用了BLOB和TEXT列并且需要使用隐式临时表，将不得不使用MYISAM磁盘
临时表。
<4>
      索引优化是对查询性能优化最有效的手段。
<5>
当数据库数据量涨到一定数量时，性能就成为我们不能不关注的问题，如何优化呢？ 常用的方式不外乎那么几种：
　　1、分表，即把一个很大的表达数据分到几个表中，这样每个表数据都不多。 
　　　　优点：提高并发量，减小锁的粒度
　　　　缺点：代码维护成本高，相关sql都需要改动
　　2、分区，所有的数据还在一个表中，但物理存储数据根据一定的规则存放在不同的文件中，文件也可以放到另外磁盘上
　　　　优点：代码维护量小，基本不用改动，提高IO吞吐量
　　　　缺点：表的并发程度没有增加
　　3、拆分业务，这个本质还是分表。
　　　　优点：长期支持更好
　　　　缺点：代码逻辑重构，工作量很大
    
<6>
msyql 5.5和5.6有default的区别

<7>
mysql分表和分区有什么联系呢？
1.都能提高mysql的性高，在高并发状态下都有一个良好的表现。
2.分表和分区不矛盾，可以相互配合的，对于那些大访问量，并且表数据比较多的表，我们可以采取分表和分区结合的方式（如果merge这种分表方式，不能和分区配合的话，可以用其他的分表试），访问量不大，但是表数据很多的表，我们可以采取分区的方式等。
3.分表技术是比较麻烦的，需要手动去创建子表，app服务端读写时候需要计算子表名。采用merge好一些，但也要创建子表和配置子表间的union关系。
4.表分区相对于分表，操作方便，不需要创建子表。
